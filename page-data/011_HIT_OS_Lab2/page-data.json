{"componentChunkName":"component---src-templates-blog-post-js","path":"/011_HIT_OS_Lab2/","result":{"data":{"site":{"siteMetadata":{"title":"JokerDebug"}},"markdownRemark":{"id":"24ad8171-270c-52c8-af14-cc2e10d6027e","excerpt":"Github代码仓库链接 本节将更新哈工大《操作系统》课程第二个 Lab 实验 操作系统的引导。按照实验书要求，介绍了非常详细的实验操作流程，并提供了超级无敌详细的代码注释。文末附完整  和  标准答案代码以及超详细注释。 实验目的： 熟悉 hit-oslab…","html":"<p><a href=\"https://github.com/Joker001014/HIT-OSlab\">Github代码仓库链接</a></p>\n<p>本节将更新哈工大《操作系统》课程第二个 Lab 实验 <strong>操作系统的引导</strong>。按照实验书要求，介绍了非常详细的实验操作流程，并提供了超级无敌详细的代码注释。文末附完整 <code class=\"language-text\">bootsect.s</code> 和 <code class=\"language-text\">setup.s</code> 标准答案代码以及超详细注释。</p>\n<p><strong>实验目的：</strong></p>\n<blockquote>\n<ul>\n<li>熟悉 hit-oslab 实验环境；</li>\n<li>建立对操作系统引导过程的深入认识；</li>\n<li>掌握操作系统的基本开发过程；</li>\n<li>能对操作系统代码进行简单的控制，揭开操作系统的神秘面纱。</li>\n</ul>\n</blockquote>\n<p><strong>实验任务：</strong></p>\n<blockquote>\n<p>1、bootsect.s 能在屏幕上打印一段提示信息“XXX is booting...”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等\r\n2、bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行\"Now we are in SETUP\"。\r\n3、setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</p>\n</blockquote>\n<p><strong>实验工具准备：</strong></p>\n<table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hit-操作系统实验指导书.pdf</td>\n<td>哈工大OS实验指导书</td>\n</tr>\n<tr>\n<td>Linux内核完全注释(修正版v3.0).pdf</td>\n<td>赵博士对Linux v0.11 OS进行了详细全面的注释和说明</td>\n</tr>\n<tr>\n<td>file1615.pdf</td>\n<td>BIOS 涉及的中断数据手册</td>\n</tr>\n<tr>\n<td>hit-oslab-linux-20110823.tar.gz</td>\n<td>hit-oslab 实验环境</td>\n</tr>\n<tr>\n<td>gcc-3.4-ubuntu.tar.gz</td>\n<td>Linux v0.11 所使用的编译器</td>\n</tr>\n<tr>\n<td><a href=\"https://joker001014.github.io/blog/019_HIT_OS_Bochs\">Bochs 汇编级调试指令</a></td>\n<td>bochs 基本调试指令大全</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.csdn.net/yueyueniaolzp/article/details/82178954\">最全ASCII码对照表0-255</a></td>\n<td>屏幕输出字符对照的 ASCII 码</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.csdn.net/weixin_53159274/article/details/138074386?spm=1001.2014.3001.5501\">x86_64 常用寄存器大全</a></td>\n<td>x86_64 常用寄存器大全</td>\n</tr>\n</tbody>\n</table>\n<h3>一、bootsect.s 的屏幕输出功能</h3>\n<blockquote>\n<p>需要实现：bootsect.s 能在屏幕上打印一段提示信息“XXX is booting...”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等</p>\n</blockquote>\n<blockquote>\n<p>参考赵博士《Linux 内核 0.11 完全注释（修正版 V3.0）》第六章，其中非常详细的解释了 Linux_v0.11 的启动引导过程。</p>\n</blockquote>\n<p>就比如下面这张图，形象生动地概括了OS引动过程：</p>\n<ol>\n<li>首先，80x86 架构CPU进入实模式（16位），从 <code class=\"language-text\">0xfff0</code> 开始自动执行代码，在地址0处初始化中断向量。</li>\n<li>从系统软盘上将第一扇区 <code class=\"language-text\">bootsect.s</code> 程序读入物理地址 <code class=\"language-text\">0x07c00</code> 处（共512 bytes），并赋给 <code class=\"language-text\">bootsect</code> 控制权。</li>\n<li>接下来 <code class=\"language-text\">bootsect.s</code> 将自身移动到 <code class=\"language-text\">0x90000</code> 处，为了腾出内存空间，以便给操作系统内核使用。</li>\n<li>将 setup.s 加载到内存 <code class=\"language-text\">0x90200</code> 处，即 <code class=\"language-text\">bootsect.s</code> 512 bytes 之后，并赋给 <code class=\"language-text\">setup.s</code> 控制权。</li>\n<li>将 <code class=\"language-text\">system</code> 模块加载到 <code class=\"language-text\">0x10000</code> 处。（不能移动到0x00000处原因：因为在执行是 setup.s 模块时，需要利用 ROM BIOS 的中断调用来获取机器的参数，不能把中断向量表、BIOS数据区给覆盖掉）</li>\n<li>将 <code class=\"language-text\">system</code> 模块移动到 <code class=\"language-text\">0x00000</code> 处，进入保护模式（32位），并赋给 <code class=\"language-text\">system</code> 控制权。</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 588px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/578d2c9fa3c06d95956f4f0c339716c5/9bbaf/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACy0lEQVR42j2TWW/kVBCF/ef4B2geeeYf8AhIPCNEgjRIDAIhITKLRGbCTBZgRt3Z1yadzvSS7sTt9OK2HbfX6637o+xBXOnKde+Rq06dU1crioLlckmWJeR5VsVLoFjkVbxYFsSJJ1hKuRaLotrlKnEvVqg0+/+s+Z7Lq1+/4eJgS36G/Z2n/Ln+BD/0ON3dYPPFY4LQp98+482zVWamQb9zzh9rK0zGOmXqq4s9tp4/ZjYdo4VhwEFtk9teq2LWahzSOKlRMr++POaovlVVH+k96jvPiST5aNhnd+cFsRQt16BzydG7l/jeHC0IAtrdHlPTJE1TdONetkGSJozGE27vjOreclz6Q4soinBcr4pVklbtj00bfeISCqYppfB9jyDwSZKEskAUhdXXtEaMZ7dEasng4jfaG49wzD56a4PWy4/x7S65MOyf/kz/zSPmto5WVvR9nziOq4RlcqViwjDkanjDcNYXLGVws0fn8nvBLWn5jG5jVVo2KUSn8eAt0/crRIGFVmqVCMskUZVuWZaxKHImD3OCJKuwsos8z8ny0oKCv1oun/yo0zGj0lspqCqHlRDSZpaFZTvSYlgxHRht7h2doeWIixPRy60SmqKxO3fx5g61xoDvtnoMLJEnVayfGHz60yVj20MzjCGH9W3uBm2cB5v6u985O9lmKiNwerzLP2f7InZMr3PN+XEdxzYZ3rS4be4SB17F8ElN56OvmyKPJExUgufapKJhEC9wvEJYZXiRDHYyZ6FckUBkCRyccZ9Q2D6ogvsH/z8JwI1S7oVtedZSGQ8lF1fDY4zmlzJUX5F1P2fUXOXZmc3aic3rhsn6ucnagbj+aoV8/QvU9rf4b38gXPuMtLfPh6ey+GBKnokJ7hBvusN88BTz+hfmkzrndx6HXYu/T7vstQwa+hzveo+suYl6XyO5OUI1XhONu2TyzEoD/wWq22+8l5Q1AQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/578d2c9fa3c06d95956f4f0c339716c5/9bbaf/1.png\"\n        srcset=\"/blog/static/578d2c9fa3c06d95956f4f0c339716c5/c26ae/1.png 158w,\n/blog/static/578d2c9fa3c06d95956f4f0c339716c5/6bdcf/1.png 315w,\n/blog/static/578d2c9fa3c06d95956f4f0c339716c5/9bbaf/1.png 588w\"\n        sizes=\"(max-width: 588px) 100vw, 588px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>1、编写 bootsect.s</strong></p>\n<p>需要注意的是，我们要从头开始编写 bootsect.s，而不是在 Linux0.11 的源码上进行修改，这样子无法深刻理解 bootsect 引导过程。</p>\n<p>解压 <code class=\"language-text\">hit-oslab-linux-20110823.tar.gz</code> ，并命名为 <code class=\"language-text\">os_lab_Lab1</code> ，在此源码基础上我们进一步完成实验。进入 <code class=\"language-text\">os_lab_Lab1/linux-0.11/boot/</code> 文件夹下的 <code class=\"language-text\">bootsect.s</code> 文件，我们清空文件内容，重头开始编写。</p>\n<ul>\n<li>获取光标位置</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">entry _start\r\n_start:\r\n! 输出一些信息\r\n    ! 读入光标位置\r\n    mov ah, #0x03\r\n    xor bh, bh             ! 显示页码设置\r\n    int 0x10</code></pre></div>\n<blockquote>\n<p>其中，中断 <code class=\"language-text\">int 10</code>、 <code class=\"language-text\">ah = 03H</code> 功能以及参数 <code class=\"language-text\">bh</code> 可以在文件 file1615.pdf 查到，如下图所示。</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4428ba971be06666d9acb18963c972cc/fcda8/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.39240506329114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACIElEQVR42lVTZ2/iUBD0//8f+ZiLEokLvQSCMYR+dIzpxRxNlFA9t/M4S+RJq32235udmV1ryWQS4WgURiQC/fkZqddX6C8vCD09Ifv+Dmw2uA0GwGwGZzqFA8BxHBW32w3usixLhbZarTAej1GtVlWUKxW0Ox0Y6TTqrRb+9vuw63VMJexmE7Ztq/MzKbBcLjGZTDCVQsRhAW0jDA6HA0ZyyJQLja8v1DIZmMUielLALJdh1Wr4UyqhJgXqAlySPXOv17uTkDPtdhvX6xVat9uFLdW4TgJu+P3IiA262DAwTVhSxJILznZ71+Y4/9Ndtru4V4Cky0pXofu926GVz6MnjAqfn8h+fKCcSiEfj6NFtmJFR4KM1uu1Ajifz7hcLioU4GKxUD6wwm6/R1IADJH82+uFPxhESJrlkf0vaZRf2AcCAUTkXaFQwOl0UkAEdYE150ECvWw0GsqXt7c3ddEwDEQJ6vEgHA4jl8v9kPwonVmjBB7aikekTDm6riugtHQ6kUioiMViiIt0fnfDFI/ZjJY0i4xpnbYT3yiblCmBl1yAUCgEzinfkW02m8V8PlcWcWweg+O0F8s0zo47pAQcDodoSmdZlRWZ+dyXeaQdHBcyY5ClOzYswqVRJsMFLMr8paQxlM3MIGPK5zvmvEwCs8ue+6A0sCI/xQ/A4/GIjHSYH30+n2qC21nmqMymVzrO76PRSLFmD/jLkT1Z/gNNUV68OHUxeAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/4428ba971be06666d9acb18963c972cc/fcda8/2.png\"\n        srcset=\"/blog/static/4428ba971be06666d9acb18963c972cc/c26ae/2.png 158w,\n/blog/static/4428ba971be06666d9acb18963c972cc/6bdcf/2.png 315w,\n/blog/static/4428ba971be06666d9acb18963c972cc/fcda8/2.png 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>输出显示字符串。同理可以查表发现，0x10中断对应的 <code class=\"language-text\">ah = 13</code> 功能为向屏幕输出显示字符串，并且各个参数的功能也都有详细介绍，具体可以参照代码及注释。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 589px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d60b8b0bb11dc462b8662670d1f8213d/b1665/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.18987341772153%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42n1TZ4siQRSc//8r/KSCqKyg6yoGPHM48xkwYc45YqjretyIeyfX8HgzPTPVVa9qtHarhR/hMHLJJH5+fCD3+YmYzYbC1xcyDgcusxkeAO73u9Tj8ZDONR6Pkc/n0ev10G630VJY2mKxQKVSQb1el4e/ymXEYzHpKXXIarXC8XjE8XDAQdVut8PpdMJ2u8V6vX7WfD6XPU0/rd/vIxAIIJPJIKYAU6kUUum0gEYiEcTjcSTVtd/vl2vuhUIhJBIJRKNReDweIaZdr1cBbDQa8qBYLAoYX5wpuWRDFbxeLpfChH2z2QgzsqIK7pG9NplM0Gw2n3MhcKFQQDabxX6/lxcJ+m5xnqzXe5F8u92eQycbHpJWcsk4GAwil8thOByi0+mIAewkQXUEYScGS9OB9MIfR6fTKdxuNywWC3w+H2zKeaPRKPdmsxkmk0lGQ9lcOqlvgDxtNBoJQzrucrlgtVrhdDrFKLKmEfqMvV6vROUtIDe46GStVhMQuh5WGaWrlN3tduVAXfpgMBBT8JLTfwAZGzKhLLJzqHBTut1uF5ZkRgXn81lMu1wu30b2NEUH5EdkZDAYRBIdZxwYbsaDcdHN+Hv+Aqg7pM+QciiLc6JMdu5Vq1UJ/6u8t4D8H8vqNyN1Ls6lVCpJfPRs/Q+AZCifxbz+BvgxvASYujfQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/d60b8b0bb11dc462b8662670d1f8213d/b1665/3.png\"\n        srcset=\"/blog/static/d60b8b0bb11dc462b8662670d1f8213d/c26ae/3.png 158w,\n/blog/static/d60b8b0bb11dc462b8662670d1f8213d/6bdcf/3.png 315w,\n/blog/static/d60b8b0bb11dc462b8662670d1f8213d/b1665/3.png 589w\"\n        sizes=\"(max-width: 589px) 100vw, 589px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">BOOTSEG = 0x07c0;    ! bootsect 程序开始的地址\r\n\r\n! 输出一些信息\r\n    ! 设置开机启动字符串\r\n    mov cx, #26            ! 字符串长度（20字符+3个回车+3个换行）\r\n    mov bx, #0x0007        ! 设置 显示页号 和 字符属性(BL表示显示颜色 01：蓝色，03：青色，07：普通白色)\r\n    mov ax, #BOOTSEG       ! 字符串 段地址\r\n    mov es, ax             ! 不能将立即数直接赋给段寄存器，ax 充当临时寄存器\r\n    mov bp, #msg1          ! 字符串 偏移地址\r\n    mov ax, #0x1301        ! ah = 13H -&gt; 显示， al = 01H -&gt; 设置文本模式\r\n    int 0x10               ! 显示服务中断\r\n\r\n! 无限循环\r\ninf_loop:\r\n\tjmp inf_loop\r\n\r\n! 显示字符串\r\nmsg1:\r\n    .byte    13,10         ! 回车 + 换行\r\n    .ascii    &quot;Joker is booting ...&quot;\r\n    .byte    13,10,13,10\r\n\r\n.org 510                   ! 将当前位置设置为内存地址 510\r\n! 设置引导扇区标记\r\n    .word    0xAA55        ! 指定引导扇区的最后两个字节，bootsect必须以它结尾，才能引导</code></pre></div>\n<blockquote>\n<p>需要注意的是：在结尾处我们需要使用 <code class=\"language-text\">.org</code> 指令 ，设置最后两个字节为 <code class=\"language-text\">bootsect</code> 程序标识。</p>\n</blockquote>\n<p>可能有不少读者不太了解 <code class=\"language-text\">org</code> 指令 ，在此处给出Unix操作系统指令大全：<a href=\"https://zhuanlan.zhihu.com/p/420247468\">115个最常用的Linux命令行大全 - 知乎 (zhihu.com)</a>，大家遇到不懂的指令可以在该文中查到。</p>\n<p><strong>2、编译和运行</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> ~/my_space/OS_HIT/oslab_Lab1/linux-0.11/boot\r\nas86 <span class=\"token parameter variable\">-0</span> <span class=\"token parameter variable\">-a</span> <span class=\"token parameter variable\">-o</span> bootsect.o bootsect.s   // 用as86编译器，编译生成目标文件 bootsect.o\r\nld86 <span class=\"token parameter variable\">-0</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-o</span> bootsect bootsect.o     // 用ld86链接器，将目标文件连接成可执行文件</code></pre></div>\n<blockquote>\n<p>直接在 <code class=\"language-text\">linux-0.11</code> 文件夹下用 <code class=\"language-text\">make all</code> 也可以，因为Makefile里面定义了这两条语句了</p>\n</blockquote>\n<p>编译后，通过 <code class=\"language-text\">ls -l</code> 指令可以查看生成文件信息。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 546px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/97af176316da22e2231fee72a849c1a0/76aed/4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.455696202531648%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnElEQVR42j2NyRLCMAxDU8jSOHHarAVOcOL/v1C4mQ6HN5ZleaRen4b394FyMOzK0GuC8ZuQLviv9anXk4S789COYMImfzKtgdYaKvGOmjsCBRhjkDgiBgLHKB7BOTu9UvLUIfh5o6RBWcHvC5abglIXaUsIEvDeSYPF6AOlNjShloIYWfaK3jvIE3IuqK1NxjHweB6okiUpZ2b8ANh1RFlJ02a/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/97af176316da22e2231fee72a849c1a0/76aed/4.png\"\n        srcset=\"/blog/static/97af176316da22e2231fee72a849c1a0/c26ae/4.png 158w,\n/blog/static/97af176316da22e2231fee72a849c1a0/6bdcf/4.png 315w,\n/blog/static/97af176316da22e2231fee72a849c1a0/76aed/4.png 546w\"\n        sizes=\"(max-width: 546px) 100vw, 546px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>需要留意的文件是 bootsect 的文件大小是 544 字节，而引导程序必须要正好占用一个磁盘扇区，即 512 个字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件处理文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部。</p>\n</blockquote>\n<ul>\n<li>因此，我们需要去掉这 32 个字节后，将生成的文件拷贝到 linux-0.11 目录下，并一定要命名为“Image”。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">dd</span> <span class=\"token assign-left variable\">bs</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>bootsect <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>Image <span class=\"token assign-left variable\">skip</span><span class=\"token operator\">=</span><span class=\"token number\">32</span>   // 去掉前 <span class=\"token number\">32</span> 个 bytes\r\n<span class=\"token function\">cp</span> ./Image <span class=\"token punctuation\">..</span>/Image                    // 移动到 linux-0.11 目录下\r\n<span class=\"token punctuation\">..</span>/<span class=\"token punctuation\">..</span>/run                              // 运行</code></pre></div>\n<p>至此，<strong>实验任务一</strong> 就完成了，实现效果如下所示。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 591px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e7c7a1a5ef72693e707da31783e54e7f/e4c9a/5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.632911392405056%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVR42o2RO0/CYBSGSym9l1sLhNuCgOFngBKwkzFx1VAgJP4DSUxYHBid2EggTPwFNwdmSISE+GNez6lSL1Hj8OQ9/fp977kJrdNTMM1GA2fNJi4vLtD3PPQ6HQx6PT/ue10M+n30ul0fj/5dX13hrN3GSb0Ot9WC67q4OW9BuB2NcHd/j4fJBI9PT3h+ecF6u8V6t/N1wzHrfo/1ZoPVaoXpdIrlconxeIzhcIj5fI7FYoHZbAZBK5WgEkalAp1UzmQgZ7NQCoVAVcKs1SCn0xBEEYIg/I5eLEKnB1ouB8myIOk6IqRMWFW/Xg6FfEKs72eHODhTKKvBFZbLMKvVAOv42D8XI5EPs78qOxDN52GRqe440FMpGBSb1LaZTEKxbYiyHFQQ+o9p5egIeZqVQ4+zpEVqv0BJchRnKEGSjFOUxKGE6vcR/IRDj2LxOKLR6JvGYkgkEj5xgo0YwzB8OIGmaT+a+R3wBYsWYJrmmykZhsPhL4i0Wb7MsUwjYP21wjS1wyZszJXotOXvhowkSYH5529FURCnzhjbtvEKUEUXInQxcG4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/e7c7a1a5ef72693e707da31783e54e7f/e4c9a/5.png\"\n        srcset=\"/blog/static/e7c7a1a5ef72693e707da31783e54e7f/c26ae/5.png 158w,\n/blog/static/e7c7a1a5ef72693e707da31783e54e7f/6bdcf/5.png 315w,\n/blog/static/e7c7a1a5ef72693e707da31783e54e7f/e4c9a/5.png 591w\"\n        sizes=\"(max-width: 591px) 100vw, 591px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>二、bootsect.s 导入 setup.s</h3>\n<blockquote>\n<p>需要实现：bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行\"Now we are in SETUP\"。</p>\n</blockquote>\n<p><strong>1、编写 setup.s 屏幕输出</strong></p>\n<p>我们首先来编写 setup.s 向屏幕输出功能，同理需要重头开始编写 setup.s，与 <code class=\"language-text\">bootsect.s</code> 类似。</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">entry _start\r\n_start:\r\n    ! 读入光标位置\r\n    mov ah, #0x03\r\n    xor bh, bh\r\n    int 0x10\r\n\r\n    ! 设置开机启动字符串\r\n    mov cx, #25            ! 字符串长度（19字符+3个回车+3个换行）\r\n    mov bx, #0x0007        ! 设置 显示页号 和 字符属性\r\n    mov ax, cs             ! 使用cs值获取 段地址\r\n    mov es, ax             ! ax 充当临时寄存器\r\n    mov bp, #msg2          ! 字符串 偏移地址\r\n    mov ax, #0x1301        ! ah = 13H -&gt; 显示， al = 01H -&gt; 设置文本模式\r\n    int 0x10\r\n\r\n! 无限循环\r\ninf_loop:\r\n    jmp inf_loop\r\n\r\n! 显示字符串\r\nmsg2:\r\n    .byte    13,10         ! 回车 + 换行\r\n    .ascii    &quot;Now we are in SETUP&quot;\r\n    .byte    13,10,13,10</code></pre></div>\n<p><strong>2、在 bootsect.s 中载入 setup.s</strong></p>\n<p>在 bootsects 中载入 setup.s ，需要用到中断 <code class=\"language-text\">int 0x13</code> 的 <code class=\"language-text\">02H</code> 号功能——从磁盘中载入数据到内存。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 588px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b3b8374da4f6289292bd0b0f446349/9bbaf/6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.06329113924051%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABl0lEQVR42oVTZ4vCUBDM//8V4mc/iAiKQuwNS9BgCRoL9oqi2M1cZo8nx3l6geHxNruzs+VpRqUCPR5HJZFA0e+HGYnAisXQTqdhuzZcLnDw/TmOg8fj8QLaTdPEcDiEtlgsMB6PYRgGisUibNvGer3GdDrFfD7HfDbDcrnEZDLBfr//SEpop9PJFXHBzA0cDAbo9/toNpuwLAuj0Uiykoz23W4nSv8iVNBIwkDl2Gg0UK1WpYTtdivqCRIrwvv9/p5QSeXleDwimUwil8vB4/HA6/UiHA4jxp622zgcDm9LfhIyG0HH8/mMQqEghIFAAD6fT3rLRFT3iehFIcF+lkol1Go1hEIhpFIpBINBsa1WKwn4t4ckYSm8XK9XmTKRz+eFkKBqKuTw6Puzh6pCZdM4QU6Ul9vtJsFUlc1mpXfRaBQJdx/ZAiZhL5lY7eXvU+POkZROJO12u6jX6+h0Ok/0ej0hUpPebDayZmo/1S7zn0YjSVgOv3K5LKqojsri7itKu6+GZyaTga7rctKHdvoQrVZL+vwFAIYvDho2GjEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/d6b3b8374da4f6289292bd0b0f446349/9bbaf/6.png\"\n        srcset=\"/blog/static/d6b3b8374da4f6289292bd0b0f446349/c26ae/6.png 158w,\n/blog/static/d6b3b8374da4f6289292bd0b0f446349/6bdcf/6.png 315w,\n/blog/static/d6b3b8374da4f6289292bd0b0f446349/9bbaf/6.png 588w\"\n        sizes=\"(max-width: 588px) 100vw, 588px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>具体代码如下所示：（除了新增代码，我们还需要去掉在 <code class=\"language-text\">bootsect.s</code> 添加的无限循环）</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">SETUPSEG = 0x07e0;               ! setup 程序开始的地址（没有移动到 0x9000 处）\r\nSETUPLEN = 4;                    ! setup 占用扇区数量\r\n\r\n! 加载 setup.s 程序\r\nload_setup:\r\n    mov    dx,#0x0000            ! 设置驱动器和磁头(drive 0, head 0)\r\n    mov    cx,#0x0002            ! 设置扇区号和磁道(sector 2, track 0)\r\n    mov    bx,#0x0200            ! 偏移地址为 512 bytes\r\n    mov    ax,#0x0200+SETUPLEN   ! ah=02H：从磁盘读数据到内存；al=04H，读入四个扇区\r\n    int    0x13                  ! 低级磁盘服务中断\r\n    jnc    ok_load_setup         ! 加载成功，跳转(无进位时跳转)\r\n    ！加载错误\r\n    mov    dx,#0x0000\r\n    mov    ax,#0x0000            ! 复位软驱\r\n    int    0x13\r\n    jmp load_setup               ! 再次尝试\r\n\r\nok_load_setup:\r\n    jmpi 0,SETUPSEG              ! 赋予 setup.s 控制权\r\n\r\n! 无限循环\r\n! inf_loop:\r\n!    jmp inf_loop\r\n</code></pre></div>\n<p><strong>3、编译和运行</strong></p>\n<p>为了加快编译速度，避免一个一个手动编译，我们将借助 <code class=\"language-text\">makefile</code> 来实现编译。我们将用到 <code class=\"language-text\">linux-0.11/tools/build.c</code> 文件来实现。注意：在使用 <code class=\"language-text\">make BootImage</code> 之前，我们需要修改一下 <code class=\"language-text\">build.c</code> 代码，因为我们还没有编写内核文件 <code class=\"language-text\">kernel</code>，所以会出现报错。</p>\n<ul>\n<li>注释掉 <code class=\"language-text\">tool/build.c</code> 中的部分代码：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//     if ((id=open(argv[3],O_RDONLY,0))&lt;0)</span>\r\n<span class=\"token comment\">//         die(\"Unable to open 'system'\");</span>\r\n<span class=\"token comment\">// //    if (read(id,buf,GCC_HEADER) != GCC_HEADER)</span>\r\n<span class=\"token comment\">// //        die(\"Unable to read header of 'system'\");</span>\r\n<span class=\"token comment\">// //    if (((long *) buf)[5] != 0)</span>\r\n<span class=\"token comment\">// //        die(\"Non-GCC header of 'system'\");</span>\r\n<span class=\"token comment\">//     for (i=0 ; (c=read(id,buf,sizeof buf))>0 ; i+=c )</span>\r\n<span class=\"token comment\">//         if (write(1,buf,c)!=c)</span>\r\n<span class=\"token comment\">//             die(\"Write call failed\");</span>\r\n<span class=\"token comment\">//     close(id);</span>\r\n<span class=\"token comment\">//     fprintf(stderr,\"System is %d bytes.\\n\",i);</span>\r\n<span class=\"token comment\">//     if (i > SYS_SIZE*16)</span>\r\n<span class=\"token comment\">//         die(\"System is too big\");</span>\r\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>即可实现编译和运行</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd linux-0.11\r\nmake BootImage\r\n../run</code></pre></div>\n<p>至此，<strong>实验任务二</strong> 就完成了，实现效果如下所示。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 591px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4168d88fe5112b13437e1983dd0e028d/e4c9a/7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.9620253164557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABvElEQVR42oWSy0ojURCGT9/oTl+S2LmZGMHLAymJV5TRwZ0k0q40ickmi+AmvoIbXcs4Mowo6kLwrX7/Ok6L4GgWP4eqU/WduhzVXFrCRrOJtUYDPzY30d7fR7/TQe/oCINuF/3jjrYHVJ/2Sa+HwyRBcnCA9bVVNJaXsb21hb3dHSTbK1A/2220GHRyeorzqyv8fX7Gr7s73Dw94vr+Hr8fHrT+vLzg+vYWlxcXGA6HGJ+dISG41WphNBphPB6j0+1BOTMzsKan4dTrsEslqCCAQalcDkYYwshGMOMYVrn85lfqkwzD0KdlWVB+tYpwYQHB3Bx8wjOE+7Waljs19R6sE/8lm6apz4+Se9u2oexsFi6hnohAb3YWrsAosU3HeQN+AH8lXWFlfh4FJkbFIvKExgTFbD9mpQF9jufpQHldJ0wCLrLdMhNLVI2QOoFyVjizCmdaLBRQpa/Ie9d1JwOzbDmMIvi+j5BLCDh4n9J+2jkuRyQwuSvwgUwm8zWwzEry+bxOkuCYG5Why2WqdAlp62L/b8t6KRGrS1+XirRzwvC/bVkqkxY8Dl/gYqdfY5IkzuEvkPFIrnT4CmhNKN1TlY1wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/4168d88fe5112b13437e1983dd0e028d/e4c9a/7.png\"\n        srcset=\"/blog/static/4168d88fe5112b13437e1983dd0e028d/c26ae/7.png 158w,\n/blog/static/4168d88fe5112b13437e1983dd0e028d/6bdcf/7.png 315w,\n/blog/static/4168d88fe5112b13437e1983dd0e028d/e4c9a/7.png 591w\"\n        sizes=\"(max-width: 591px) 100vw, 591px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>三、setup.s 获取硬件参数并输出显示</h3>\n<blockquote>\n<p>需要实现：setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</p>\n</blockquote>\n<p><strong>1、获取硬件参数</strong></p>\n<p>获取硬件参数的代码大致都一样，我们将主要介绍 <strong>获取内存大小</strong> 和 <strong>获取磁盘参数表</strong>，其他参数获取参考文末代码。</p>\n<ul>\n<li>要获取内存大小，我们需要用到中断 <code class=\"language-text\">int 0x15</code>，调用 <code class=\"language-text\">ah = 0x88</code> 功能实现。具体代码如下：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">BOOTSEG = 0x07c0;         ! bootsect 读入段地址\r\nINITSEG = 0x9000;         ! 初始数据段存放的位置\r\nSETUPSEG = 0x07e0;        ! setup 程序开始的地址（没有移动到 0x90200 处）\r\n\r\n! 设置段地址，将硬件参数取出来放在内存 0x90000\r\n    mov ax, #INITSEG\r\n    mov ds, ax            ! 数据段地址 ds = 0x9000\r\n\r\n! 读光标位置，存入 dx\r\n    mov ah, #0x03         ! AH = 3 -&gt; 读光标位置\r\n    xor bh, bh            ! 显示页数 = 0\r\n    int 0x10\r\n    ! 将光标位置写入 0x90000.\r\n    mov [0], dx\r\n\r\n! 读入内存大小位置\r\n    mov ah, #0x88         ! AH = 0x88 -&gt; 读入内存大小\r\n    int 0x15              ! 内存大存入 AX\r\n    mov [2], ax           ! 存入 9000 后面两个偏移</code></pre></div>\n<ul>\n<li>获取磁盘参数表，。在 PC 机中 BIOS 设定的中断向量表中 int 0x41 的中断向量位置 <code class=\"language-text\">4*0x41 = 0x0000:0x0104</code>存放着第一个硬盘的基本参数表。第二个硬盘的基本参数表入口地址存于 int 0x46 中断向量位置处。每个硬盘参数表有 16 个字节大小。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">! 获取磁盘参数表，从 0x41 处拷贝 16 个字节\r\n    mov ax, #0x0000       ! 不允许直接将立即数加载到段寄存器，需要使用通用寄存器ax\r\n    mov ds, ax            ! 数据段地址 ds = 0x0000\r\n    lds    si,[4*0x41]    ! 取中断向量 41 的值，即 hd0 参数表的地址 ds:si\r\n    mov    ax,INITSEG\r\n    mov    es,ax\r\n    mov    di,#0x0080     ! 传输的目的地址: es:di = 9000:0080\r\n    mov    cx,#0x10       ! 重复执行次数 = 16\r\n    rep                   ! 重复执行movsb, DS:SI -&gt; ES:DI\r\n    movsb                 ! 每执行一次 movsb 指令，源地址和目的地址的偏移都会自动递增</code></pre></div>\n<p><strong>2、显示获得的参数</strong></p>\n<p>为了以 16进制 的形式显示获取的参数，我们需要编写显示函数。（ASCII码请参考：<a href=\"https://blog.csdn.net/yueyueniaolzp/article/details/82178954\">最全ASCII码对照表0-255</a>）</p>\n<blockquote>\n<p>以十六进制方式显示比较简单。这是因为十六进制与二进制有很好的对应关系（每 4 位二进制数和 1 位十六进制数存在一一对应关系），显示时只需将原二进制数每 4 位划成一组，按组求对应的 ASCII 码送显示器即可。分为两种情况</p>\n<ul>\n<li>数字 0<del>9 ： 对应 ASCII 码为 0x30</del>0x39，故显示时加上 0x30</li>\n<li>数字 a<del>f ：对应ASCII码为 0x41</del>0x46，故显示时在原先加 0x30 的基础上，还要添加 0x07</li>\n</ul>\n</blockquote>\n<ul>\n<li>相关显示函数如下所示。将临时寄存器 <code class=\"language-text\">ax</code> 中存放的16位二进制数，通过4位十六进制的ASCII字符进行显示。其中使用循环左移 <code class=\"language-text\">rol</code> 不断获取高位数据 -> 并通过 <code class=\"language-text\">and</code> 操作保留第四位数据 -> 再统一加上 0x30 之后判断是否大于数字9，若大于再加上 0x07。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">! 以 16 进制 打印寄存器 ax 中的16位数\r\nprint_hex:\r\n    mov cx, #4        ! 循环次数s\r\n    mov dx,ax         ! 将ax所指的值放入dx中，ax作为参数传递寄存器\r\nprint_digit:\r\n    rol dx,#4         ! 将 DX 寄存器中的值向左循环移位 4 位，相当于将 最高的4位 移到 最低的4位。后面取出最低四位，打印的时候实现高位在前\r\n    mov ax,#0x0e0f     ! ah = 0eh -&gt; 显示字符, al = 字符：半字节(4个比特)掩码。\r\n    and al,dl         ! 取 dl 的低4比特值。\r\n    add al,#0x30      ! 给al数字加上十六进制 0x30, 0~9 + 0x30 = &quot;0~9&quot;\r\n    cmp al,#0x3a      ! 判断 al 是否大于 字符 9\r\n    jl outp           ! al &lt; 数字&quot;9&quot;后面的字符，说明是 0～9，则跳转\r\n    add al,#0x07      ! al &gt; &quot;9&quot;, 是a~f,要多加7h\r\noutp:\r\n    int 0x10          ! 打印字符存储在 al 中\r\n    loop print_digit  ! cx = 4,循环四次\r\n    ret               ! 函数返回指令，表示函数执行结束，返回到调用该函数的位置\r\n\r\n！ 打印显示回车换行\r\nprint_nl:\r\n    mov ax, #0x0e0d\r\n    int 0x10\r\n    mov al, #0x0a\r\n    int 0x10\r\n    ret</code></pre></div>\n<blockquote>\n<p>回车和换行的区别\r\n回车（13）：表示光标移动到<strong>当前行的开头</strong>，但不改变行号\r\n换行（10）：表示光标<strong>移动到下一行</strong>，但不会移动到行首</p>\n</blockquote>\n<ul>\n<li>调用显示函数来实现硬件参数显示：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">! 开始显示参数\r\n! 前面修改了ds数据段寄存器，这里将其设置为0x9000\r\n    mov ax,#INITSEG        ! 设置数据段地址，后续显示硬件参数使用\r\n    mov ds,ax              ! 0x9000\r\n    mov ax,#SETUPSEG       ! 设置附加段地址，后续显示字符串使用\r\n    mov    es,ax           ! 0x07e0\r\n\r\n! 显示 光标位置\r\n    ! 获取光标位置\r\n    mov    ah,#0x03        \r\n    xor    bh,bh\r\n    int    0x10\r\n    ! 显示字符串\r\n    mov bp, #cur           ! 串 偏移地址\r\n    mov cx, #11            ! 串 长度\r\n    mov bx, #0x0003        ! 页号 = 0 + 颜色设置（03：青色，07：普通白色）\r\n    mov ax, #0x1301        ! 显示字符串 + char...\r\n    int 0x10\r\n    ! 显示数值\r\n    mov ax, [0]            ! 打印函数参数存入 ax\r\n    call print_hex         ! 调用打印寄存器函数\r\n    call print_nl          ! 打印回车换行\r\n\r\n! 显示 内存大小\r\n    ! 获取光标位置\r\n    mov    ah,#0x03        \r\n    xor    bh,bh\r\n    int    0x10\r\n    ! 显示字符串提示\r\n    mov bp, #mem\r\n    mov cx, #12\r\n    mov bx, #0x0007        \r\n    mov ax, #0x1301        ! 显示字符串 + char...\r\n    int 0x10\r\n    ! 显示数值\r\n    mov ax, [2]\r\n    call print_hex\r\n    ! 显示 KB\r\n    mov    ah,#0x03        ! read cursor pos\r\n    xor    bh,bh\r\n    int    0x10\r\n    mov    cx,#6\r\n    mov    bx,#0x0007      ! page 0, attribute c \r\n    mov    bp,#cyl\r\n    mov    ax,#0x1301      ! write string, move cursor\r\n    int    0x10\r\n\r\n! 无限循环\r\ninf_loop:\r\n    jmp inf_loop\r\n\r\n! 显示字符串\r\nmsg2:\r\n    .byte    13,10         ! 回车 + 换行\r\n    .ascii    &quot;Now we are in SETUP&quot;\r\n    .byte    13,10,13,10\r\n\r\n! 光标位置\r\ncur:\r\n    .ascii    &quot;Cursor POS:&quot;\r\n\r\n! 内存大小\r\nmem:\r\n    .ascii    &quot;Memory SIZE:&quot;\r\n\r\n! 提示信息\r\ncyl:\r\n    .ascii &quot;KB&quot;\r\n    .byte 13,10,13,10</code></pre></div>\n<p>至此，<strong>实验任务三</strong> 就完成了，实现效果如下所示。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 588px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/01bc8834332bf8b68ffe82970c938695/9bbaf/8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.08860759493672%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB7ElEQVR42qVSTU8aURR98wEDM8NHYICJChp3/hCdgIktElO7wQ+6MY1QQtImQBeadiNoZ9Fta5OyMbHduPPPnZ47LcSaIE26ODn33Xlz7rn3XXV8cIDjZhOvDg/R63Tw8fwcV6MRri4u8Gk8Jo8Qji8RSo64ZG44GOD9cIjW0RFe7u+jfXqKTruND93XUC9OTtDs9fDm7Ayfb24wubvD19tbfPvD1z9+4pr8/f4eXyYThGGIbreLfr+PVquFJg1JPGCB3tt3UGapBMPzYBSL0ByHCRMqHodKJGas2UloqRSUZUEp9TTs5WWk1tfhEs7KCuylpYjdtTVYuRw0XtI0bca6rs8Q5R/kJFYmf7IomiyXYVcqSAgYJykoOT0W+11ZLgsWOSytrsLzfWQKhQg5xh4L5DkKO5uFybYNw0CMwsLaItEK2ytyhl4+jwLZp5CgxJn6RI4d+CxSZByXmS5ymE6nIXD4ICkO3rZtuORMJgPXdTH9nuDjyB2PRSWeKyiVs2xNnOTpUmIZsLT3+AEkZ3IL5DxXUFxIRWFx8OTlf4HLFh3C4o5NW1Q6V8TQ/nIqPA8PO1EGRWShLZmVLO//uBPU9/bwbHcXz+t1NBoN7NR2sBFsoByUsb21jc2tTQRBEKFaraJWq0U8xePzL29yYRvhcUYsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/01bc8834332bf8b68ffe82970c938695/9bbaf/8.png\"\n        srcset=\"/blog/static/01bc8834332bf8b68ffe82970c938695/c26ae/8.png 158w,\n/blog/static/01bc8834332bf8b68ffe82970c938695/6bdcf/8.png 315w,\n/blog/static/01bc8834332bf8b68ffe82970c938695/9bbaf/8.png 588w\"\n        sizes=\"(max-width: 588px) 100vw, 588px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>至此，Lab2 实验介绍完毕，文末将附上 <code class=\"language-text\">bootsect.s</code> 和 <code class=\"language-text\">setup.s</code> 完整代码及详细注释。</p>\n<p><code class=\"language-text\">实验 Lab2 代码与 Linux-0.11 代码的区别在于:</code></p>\n<ul>\n<li>Lab2 无需将 bootsect.s 从 0x07c00 移动到 0x90000，故  setup.s 存放在其后 0x07e00 段位置处，也没有移动到 0x90200</li>\n</ul>\n<h3>四、完整代码汇总</h3>\n<p>bootsect.s</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">! 声明了几个全局符号，用来标识程序的代码段、数据段和未初始化数据段的起始和结束位置\r\n.globl begtext, begdata, begbss, endtext, enddata, endbss\r\n.text                 ! 接下来的指令是 代码段\r\nbegtext:              ! 标识代码段的起始位置\r\n.data                 ! 接下来的指令是 数据段\r\nbegdata:              ! 标识数据段的起始位置\r\n.bss                  ! 接下来的指令是 未初始化数据段\r\nbegbss:               ! 标识未初始化数据段的起始位置\r\n.text                 ! 接下来的指令是 代码段\r\n\r\n\r\nBOOTSEG = 0x07c0;     ! bootsect 程序开始的地址\r\nSETUPSEG = 0x07e0;    ! setup 程序开始的地址（没有移动到 0x9000 处）\r\nSETUPLEN = 4;         ! setup 占用扇区数量\r\n\r\n! 指定程序的入口点 为 _start\r\nentry _start\r\n_start:\r\n\r\n! 从go标号处开始执行，并设置代码段 cs = BOOTSEG\r\n    jmpi    go,BOOTSEG\r\n! 设置 ds=es=cs\r\ngo:    mov    ax,cs\r\n    mov    ds,ax  \r\n    mov    es,ax\r\n\r\n! 输出一些信息\r\n    ! 读入光标位置\r\n    mov ah, #0x03\r\n    xor bh, bh             ! 显示页码设置\r\n    int 0x10\r\n\r\n    ! 设置开机启动字符串\r\n    mov cx, #26            ! 字符串长度（20字符+3个回车+3个换行）\r\n    mov bx, #0x0007        ! 设置 显示页号 和 字符属性\r\n    mov ax, #BOOTSEG       ! 字符串 段地址\r\n    mov es, ax             ! 不能将立即数直接赋给段寄存器，ax 充当临时寄存器\r\n    mov bp, #msg1          ! 字符串 偏移地址\r\n    mov ax, #0x1301        ! ah = 13H -&gt; 显示， al = 01H -&gt; 设置文本模式\r\n    int 0x10               ! 显示服务中断\r\n\r\n! 加载 setup.s 程序\r\nload_setup:\r\n    mov    dx,#0x0000            ! 设置驱动器和磁头(drive 0, head 0)\r\n    mov    cx,#0x0002            ! 设置扇区号和磁道(sector 2, track 0)\r\n    mov    bx,#0x0200            ! 偏移地址为 512 bytes\r\n    mov    ax,#0x0200+SETUPLEN   ! ah=02H：从磁盘读数据到内存；al=04H，读入四个扇区\r\n    int    0x13                  ! 低级磁盘服务中断\r\n    jnc    ok_load_setup         ! 加载成功，跳转\r\n    ！加载错误\r\n    mov    dx,#0x0000\r\n    mov    ax,#0x0000            ! 复位软驱\r\n    int    0x13\r\n    jmp load_setup               ! 再次尝试\r\n\r\n! 加载成功后，开始执行setup代码\r\nok_load_setup:\r\n    jmpi 0,SETUPSEG\r\n\r\n\r\n! 显示字符串\r\nmsg1:\r\n    .byte    13,10               ! 回车 + 换行\r\n    .ascii    &quot;Joker is booting ...&quot;\r\n    .byte    13,10,13,10\r\n\r\n! 将当前位置设置为内存地址 510 字节处\r\n.org 510                \r\n! 设置引导扇区标记\r\n    .word    0xAA55               ! 指定引导扇区的最后两个字节，bootsect必须以它结尾，才能引导\r\n\r\n.text            \r\nendtext:        ! 标识代码段的结束位置\r\n.data\r\nenddata:        ! 标识数据段的结束位置\r\n.bss\r\nendbss:         ! 标识未初始化数据段的结束位置</code></pre></div>\n<p>setup.s</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">BOOTSEG = 0x07c0;        ! bootsect 读入段地址\r\nINITSEG = 0x9000;        ! 初始数据段存放的位置\r\nSETUPSEG = 0x07e0;       ! setup 程序开始的地址（没有移动到 0x9000 处）\r\n\r\n! 指定程序的入口点 为 _start\r\nentry _start\r\n_start:\r\n\r\n! 从go标号处开始执行，并设置代码段 cs = SETUPSEG\r\n    jmpi    go,SETUPSEG\r\n! 设置 ds=es=cs\r\ngo:    mov    ax,cs\r\n    mov    ds,ax  \r\n    mov    es,ax\r\n\r\n! 输出一些信息\r\n    ! 读入光标位置\r\n    mov ah, #0x03\r\n    xor bh, bh\r\n    int 0x10\r\n\r\n    ! 设置开机启动字符串\r\n    mov cx, #25            ! 字符串长度（20字符+3个回车+3个换行）\r\n    mov bx, #0x0007        ! 设置 显示页号 和 字符属性\r\n    mov ax, cs             ! 使用cs值获取 段地址\r\n    mov es, ax             ! ax 充当临时寄存器\r\n    mov bp, #msg2          ! 字符串 偏移地址\r\n    mov ax, #0x1301        ! ah = 13H -&gt; 显示， al = 01H -&gt; 设置文本模式\r\n    int 0x10\r\n\r\n\r\n! 设置数据段ds，将硬件参数取出来放在内存 0x90000\r\n    mov ax, #INITSEG\r\n    mov ds, ax             ! 数据段地址 ds = 0x9000\r\n\r\n! 读光标位置，存入数据段\r\n    mov ah, #0x03          ! AH = 3 -&gt; 读光标位置\r\n    xor bh, bh             ! 显示页数 = 0\r\n    int 0x10\r\n    ! 将光标位置写入 0x90000.\r\n    mov [0], dx\r\n\r\n! 读入内存大小位置\r\n    mov ah, #0x88          ! AH = 0x88 -&gt; 读入内存大小\r\n    int 0x15\r\n    mov [2], ax            ! 存入 9000 后面两个偏移\r\n\r\n! 获取磁盘参数表，从 0x41 处拷贝 16 个字节\r\n    mov ax, #0x0000        ! 不允许直接将立即数加载到段寄存器，需要使用通用寄存器ax\r\n    mov ds, ax             ! 数据段地址 ds = 0x0000\r\n    lds    si,[4*0x41]     ! 取中断向量 41 的值，即 hd0 参数表的地址 ds:si\r\n    mov    ax,INITSEG\r\n    mov    es,ax\r\n    mov    di,#0x0080      ! 传输的目的地址: es:di = 9000:0080\r\n    mov    cx,#0x10        ! 重复执行次数 = 16\r\n    rep                    ! 重复执行movsb, DS:SI -&gt; ES:DI\r\n    movsb                  ! 每执行一次 movsb 指令，源地址和目的地址的偏移都会自动递增\r\n\r\n\r\n! 开始显示参数\r\n! 前面修改了ds数据段寄存器，这里将其设置为0x9000\r\n    mov ax,#INITSEG        ! 设置数据段地址，后续显示硬件参数使用\r\n    mov ds,ax              ! 0x9000\r\n    mov ax,#SETUPSEG       ! 设置附加段地址，后续显示字符串使用\r\n    mov    es,ax           ! 0x07e0\r\n\r\n! 显示 光标位置\r\n    ! 获取光标位置\r\n    mov    ah,#0x03        \r\n    xor    bh,bh\r\n    int    0x10\r\n    ! 显示字符串\r\n    mov bp, #cur           ! 串 偏移地址\r\n    mov cx, #11            ! 串 长度\r\n    mov bx, #0x0003        ! 页号 = 0 + 颜色设置（03：青色，07：普通白色）\r\n    mov ax, #0x1301        ! 显示字符串 + char...\r\n    int 0x10\r\n    ! 显示数值\r\n    mov ax, [0]            ! 打印函数参数存入 ax\r\n    call print_hex         ! 调用打印寄存器函数\r\n    call print_nl          ! 打印回车换行\r\n\r\n! 显示 内存大小\r\n    ! 获取光标位置\r\n    mov    ah,#0x03        \r\n    xor    bh,bh\r\n    int    0x10\r\n    ! 显示字符串提示\r\n    mov bp, #mem\r\n    mov cx, #12\r\n    mov bx, #0x0007        \r\n    mov ax, #0x1301        ! 显示字符串 + char...\r\n    int 0x10\r\n    ! 显示数值\r\n    mov ax, [2]\r\n    call print_hex\r\n    ! 显示 KB\r\n    mov    ah,#0x03        ! read cursor pos\r\n    xor    bh,bh\r\n    int    0x10\r\n    mov    cx,#6\r\n    mov    bx,#0x0007      ! page 0, attribute c \r\n    mov    bp,#cyl\r\n    mov    ax,#0x1301      ! write string, move cursor\r\n    int    0x10\r\n\r\n\r\n! 无限循环\r\ninf_loop:\r\n    jmp inf_loop\r\n\r\n! 以 16 进制 打印寄存器 ax 中的16位数\r\nprint_hex:\r\n    mov cx, #4             ! 循环次数s\r\n    mov dx,ax              ! 将ax所指的值放入dx中，ax作为参数传递寄存器\r\nprint_digit:\r\n    rol dx,#4              ! 将 DX 寄存器中的值向左循环移位 4 位，相当于将 高4位 移到 低4位\r\n    mov ax,#0xe0f          ! ah = 0eh -&gt; 显示字符, al = 字符：半字节(4个比特)掩码。\r\n    and al,dl              ! 取 dl 的低4比特值。\r\n    add al,#0x30           ! 给al数字加上十六进制 0x30, 0~9 + 0x30 = &quot;0~9&quot;\r\n    cmp al,#0x3a           ! 判断 al 是否大于 字符 9\r\n    jl outp                ! al &lt; 数字&quot;9&quot;后面的字符，说明是 0～9，则跳转\r\n    add al,#0x07           ! al &gt; &quot;9&quot;, 是a~f,要多加7h\r\noutp:\r\n    int 0x10               ! 打印字符存储在 al 中\r\n    loop print_digit       ! cx = 4,循环四次\r\n    ret                    ! 函数返回指令，表示函数执行结束，返回到调用该函数的位置\r\n\r\n! 打印回车换行\r\nprint_nl:\r\n    mov ax, #0x0e0d\r\n    int 0x10\r\n    mov al, #0x0a\r\n    int 0x10\r\n    ret\r\n\r\n! 显示字符串\r\nmsg2:\r\n    .byte    13,10        ! 回车 + 换行\r\n    .ascii    &quot;Now we are in SETUP&quot;\r\n    .byte    13,10,13,10\r\n\r\n! 光标位置\r\ncur:\r\n    .ascii    &quot;Cursor POS:&quot;\r\n\r\n! 内存大小\r\nmem:\r\n    .ascii    &quot;Memory SIZE:&quot;\r\n\r\n! 提示信息\r\ncyl:\r\n    .ascii &quot;KB&quot;\r\n    .byte 13,10,13,10</code></pre></div>","frontmatter":{"title":"【哈工大_操作系统实验】Lab2 操作系统的引导","date":"September 01, 2024","description":"本文将介绍哈工大操作系统实验课Lab2 操作系统的引导"}},"previous":{"fields":{"slug":"/010_HIT_OS_Lab1/"},"frontmatter":{"title":"【哈工大_操作系统实验】Lab1 熟悉实验环境"}},"next":{"fields":{"slug":"/012_HIT_OS_Lab3/"},"frontmatter":{"title":"【哈工大_操作系统实验】Lab3 系统调用"}}},"pageContext":{"id":"24ad8171-270c-52c8-af14-cc2e10d6027e","previousPostId":"c9440984-c8ea-5088-8297-a4fec02e41b7","nextPostId":"cba3263f-08ed-5367-b800-3514ab6a2aa5"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}