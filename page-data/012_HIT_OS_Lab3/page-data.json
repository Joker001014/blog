{"componentChunkName":"component---src-templates-blog-post-js","path":"/012_HIT_OS_Lab3/","result":{"data":{"site":{"siteMetadata":{"title":"JokerDebug"}},"markdownRemark":{"id":"cba3263f-08ed-5367-b800-3514ab6a2aa5","excerpt":"Github代码仓库链接 本节将更新哈工大《操作系统》课程第三个 Lab…","html":"<p><a href=\"https://github.com/Joker001014/HIT-OSlab\">Github代码仓库链接</a></p>\n<p>本节将更新哈工大《操作系统》课程第三个 Lab 实验 <strong>系统调用</strong>。按照实验书要求，介绍了非常详细的实验操作流程，并提供了超级无敌详细的代码注释。文末附完整标准答案代码，包括系统调用实现 <code class=\"language-text\">who.c</code> 和测试函数 <code class=\"language-text\">iam.c</code>、<code class=\"language-text\">whoami.c</code> 以及超详细注释。</p>\n<p><strong>实验目的：</strong></p>\n<blockquote>\n<ul>\n<li>建立对系统调用接口的深入认识；</li>\n<li>掌握系统调用的基本过程；</li>\n<li>能完成系统调用的全面控制；</li>\n<li>为后续实验做准备。</li>\n</ul>\n</blockquote>\n<p><strong>实验任务：</strong></p>\n<blockquote>\n<p>在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。\r\n1、第一个系统调用是 iam()，完成的功能是将字符串参数 name 的内容拷贝到内核中保存下来。要求 name 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 name 的字符个数超过了 23，则返回 “-1”，并置 errno 为EINVAL。\r\n2、第二个系统调用是 whoami()，它将内核中由 iam() 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 name 越界访存（name 的大小由 size 说明）。返回值是拷贝的字符数。如果 size 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。\r\n3、运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。</p>\n</blockquote>\n<p><strong>实验工具准备：</strong></p>\n<table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hit-操作系统实验指导书.pdf</td>\n<td>哈工大OS实验指导书</td>\n</tr>\n<tr>\n<td>Linux内核完全注释(修正版v3.0).pdf</td>\n<td>赵博士对Linux v0.11 OS进行了详细全面的注释和说明</td>\n</tr>\n<tr>\n<td>file1615.pdf</td>\n<td>BIOS 涉及的中断数据手册</td>\n</tr>\n<tr>\n<td>hit-oslab-linux-20110823.tar.gz</td>\n<td>hit-oslab 实验环境</td>\n</tr>\n<tr>\n<td>gcc-3.4-ubuntu.tar.gz</td>\n<td>Linux v0.11 所使用的编译器</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.csdn.net/weixin_53159274/article/details/137796343?spm=1001.2014.3001.5501\">Bochs 汇编级调试指令</a></td>\n<td>bochs 基本调试指令大全</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.csdn.net/yueyueniaolzp/article/details/82178954\">最全ASCII码对照表0-255</a></td>\n<td>屏幕输出字符对照的 ASCII 码</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.csdn.net/weixin_53159274/article/details/138074386?spm=1001.2014.3001.5501\">x86_64 常用寄存器大全</a></td>\n<td>x86_64 常用寄存器大全</td>\n</tr>\n</tbody>\n</table>\n<h3>一、应用程序如何调用系统调用</h3>\n<p><strong>1、创建实验工程 oslab_Lab2</strong></p>\n<ul>\n<li>解压 <code class=\"language-text\">hit-oslab-linux-20110823.tar.gz</code> ，并命名为 <code class=\"language-text\">os_lab_Lab2</code> ，在此源码基础上我们进一步完成实验。</li>\n<li>编译及运行：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> ~/my_space/OS_HIT/oslab_Lab2/linux-0.11/    // 工程文件夹\r\n<span class=\"token function\">make</span> all                                       // 编译\r\n<span class=\"token punctuation\">..</span>/run                                         // 启动 Bochs</code></pre></div>\n<p><strong>2、创建 NR_whoami 和 NR_iam 两个宏</strong></p>\n<p><strong>注意</strong>：此时不是修改内核目录里的，而是修改在 v0.11 的开发环境里的这个文件。（这步很多同学会犯错，导致后续在 linux-v0.11 环境下使用 <code class=\"language-text\">gcc</code> 编译测试函数时报错找不到这两个宏）</p>\n<blockquote>\n<p><strong>具体原因</strong>：可以参照《Linux内核完全注释(修正版v3.0).pdf》</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 467px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/618b6e6c956a64b2e1edb3d554a6ea8b/85ff8/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.78481012658228%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGklEQVR42i1QXW+CQBDk//+lpn1oGy0EWhERhMODgztMtELF8CXJdO/iw2b3JrczO2M1bYu8KKDqGjznKESBIz9CCIHz5QwpK1RVhQvNSklTUkrCShS0pztjDJx2sozBkgSUpYAoctS1IiIizI6olSIRReSchHISKk1XGj+dUEkFlmWQ9M5JnBN5kqawIsaRcIEwzfD+HePVjfBiB3hzQzhBgtUmwsqP8OEFZl77B3z5Mbw9g709wAmp71LCI3z+RLDcMIFH5RBgb2O4uwTrTUhLe3Odtqev05HoEqV2RHb1VRSR/pOSVY2n7Gn59tcayznloCgzjV2vvxjGAY/HjGmaMM8zlmUx8ziO6Pve1DD06Lob7vcOTdPgH3CvawqTGB+eAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/618b6e6c956a64b2e1edb3d554a6ea8b/85ff8/1.png\"\n        srcset=\"/blog/static/618b6e6c956a64b2e1edb3d554a6ea8b/c26ae/1.png 158w,\n/blog/static/618b6e6c956a64b2e1edb3d554a6ea8b/6bdcf/1.png 315w,\n/blog/static/618b6e6c956a64b2e1edb3d554a6ea8b/85ff8/1.png 467w\"\n        sizes=\"(max-width: 467px) 100vw, 467px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>挂载 linux-v0.11 的磁盘，并在 include/unistd.h 中添加宏</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd oulab_Lab2\r\nsudo ./mount-hdc\r\ncd hdc/usr/include\r\ngedit unistd.h</code></pre></div>\n<ul>\n<li>通过文本编辑器，在 unistd.h 头文件中手动添加宏</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#define __NR_iam        72\r\n#define __NR_whoami        73</code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 322px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/792620b4e7c0135376566890b0f9841b/fc778/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.848101265822784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVR42k2R6XKCQBCEff+3SiVVJmWMIRBQEZFzORUFOeToNJs/btXWHrPzTffs4uNTgWMs4ekvCK0N4uMauTjg0dUQhxWC7RJF6sHfvkJYa4TmO+eK8QZ5uIM4bjCPvu8xDAMWX4oGYasQ5gdSb4vU1XCJT3zQIfN0JO4vrpkrYfOaOirvdLR1hfstkfvpGajvDoiZKKyVDGa+jiJx0NyviE8KIvtbnqPTvNpU+obY0QgsCcxk8Wl6AmrGngoV2pgVGpyatNg/WhZQJfSWBwRvWKRAeRYoiwQDAVUR4ywsqXAYeozjSKBOIJPC/ZLJKi394BLZ6NmjjMCEFq+ZJ+N3gtr6RkWT7FtJYC6OGMaJPe3Qti0Wxs5ERKshe5T4eyRUmRNYV7TM+4j20uDfRcDPiBlvmwZd1yKLfQjXRFlVKIoL8jzDH2C5vRECtmvsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"\"\n        src=\"/blog/static/792620b4e7c0135376566890b0f9841b/fc778/2.png\"\n        srcset=\"/blog/static/792620b4e7c0135376566890b0f9841b/c26ae/2.png 158w,\n/blog/static/792620b4e7c0135376566890b0f9841b/6bdcf/2.png 315w,\n/blog/static/792620b4e7c0135376566890b0f9841b/fc778/2.png 322w\"\n        sizes=\"(max-width: 322px) 100vw, 322px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>二、从“int 0x80”进入内核函数</h3>\n<p>用户程序调用进入内核的步骤</p>\n<blockquote>\n<ol>\n<li>init/main.c 内核初始化时，调用量  sched_init() 初始化函数</li>\n<li>kernel/sched.c 中定义sched_init： <code class=\"language-text\">void sched_init(void) { // …… set_system_gate(0x80,&amp;system_call); }</code></li>\n<li>include/asm/system.h 定义宏 set_system_gate ：<code class=\"language-text\">#define set_system_gate(n,addr) _set_gate(&amp;idt[n],15,3,addr)</code></li>\n<li>include/asm/system.h 定义宏 _ set_gate ：填写IDT（中断描述符表），将 system_call 函数地址写到 0x80 对应的中断描述符中，也就是在中断 0x80 发生后，自动调用函数 system_call。</li>\n</ol>\n</blockquote>\n<p><strong>1、修改 kernel/system_call.s  文件中的系统调用总数</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 由原来的 72 修改为 74\r\nnr_system_calls = 74</code></pre></div>\n<p><strong>2、在 include/linux/sys.h 文件中增加 whoami() 和 iam() 两个函数声明</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">extern int sys_whoami();\r\nextern int sys_iam();\r\nfn_ptr sys_call_table[] = { sys_setup,sys_exit, sys_fork, sys_read,..., sys_iam, sys_whoami }    // 表中添加的函数顺序必须和 _NR_xxxxxx 的值对应</code></pre></div>\n<h3>三、实现 sys_iam() 和 sys_whoami()</h3>\n<blockquote>\n<p>我需要编写系统调用函数来实现这两个功能。值得注意的是，每个系统调用都有一个 sys_xxxxxx() 与之对应，它们都是我们学习和模仿的好对象。</p>\n</blockquote>\n<ul>\n<li>此处的要点是如何实现：<strong>在用户态和核心态之间传递数据</strong>。其难点是：指针参数传递的是应用程序所在地址空间的逻辑地址，在内核中如果直接访问这个地址，访问到的是<strong>内核空间中的数据</strong>，不会是用户空间的。</li>\n</ul>\n<p>以 <code class=\"language-text\">open</code> 为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">lib/open.c：\r\n\t- 系统调用是用 eax、ebx、ecx、edx 寄存器来传递参数的\r\n\t- 获取用户地址空间（用户数据段）中的数据依靠的就是段寄存器 fs，下面该转到 sys_open 执行了\r\nfs/open.c：\r\n\t- 将参数传给了 open_namei()\r\n\t- open_namei( ) 用 get_fs_byte() 获得一个字节的用户空间中的数据</code></pre></div>\n<p>所以说，在whoami() 中实现用户态和和心态之间的数据传递，即通过：<strong>put_fs_xxx() 和 get_fs_xxx() 都是用户空间和内核空间之间的桥梁</strong></p>\n<ul>\n<li>在 <code class=\"language-text\">oslab_Lab2/linux-0.11/kernel/</code> 文件夹下创建系统调用实现 <code class=\"language-text\">who.c</code>。具体代码如下：（已有详细注释，此处将不再赘述）</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// sys_iam 和 sys_whoami 系统调用函数</span>\r\n\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;errno.h></span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;asm/segment.h></span></span>\r\n\r\n<span class=\"token comment\">// 内核中存放name，23字符 + '\\0' = 24</span>\r\n<span class=\"token keyword\">char</span> msg<span class=\"token punctuation\">[</span><span class=\"token number\">24</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// 将字符串参数 name 拷贝到内核中保存下来</span>\r\n<span class=\"token comment\">// return：拷贝的字符数。如果name的字符个数超过了23,则返回“­-1”,并置errno为EINVAL。</span>\r\n<span class=\"token keyword\">int</span> <span class=\"token function\">sys_iam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> name<span class=\"token punctuation\">)</span> \r\n<span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">char</span> tmp<span class=\"token punctuation\">[</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 临时存储，操作失败不影响 msg</span>\r\n    \r\n    <span class=\"token comment\">// 从用户态内存获取数据，存入 tmp</span>\r\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">get_fs_byte</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token char\">'\\0'</span><span class=\"token punctuation\">)</span>\r\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token comment\">// printk(tmp);</span>\r\n\r\n    i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// 计算 name 的长度</span>\r\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token char\">'\\0'</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// 长度大于 23 返回报错</span>\r\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">></span> <span class=\"token number\">23</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>EINVAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// 将由 iam() 保存的名字拷贝到 name 指向的用户地址空间，size 指定 name 的大小</span>\r\n<span class=\"token comment\">// return：如果size小于需要的空间,则返回“­-1”,并置errno为 EINVAL</span>\r\n<span class=\"token keyword\">int</span> <span class=\"token function\">sys_whoami</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">{</span>     \r\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// 计算长度</span>\r\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> msg<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token char\">'\\0'</span><span class=\"token punctuation\">;</span> len<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// 长度大于则返回</span>\r\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">></span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>EINVAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token comment\">// 从内核态获取数据，存入 name</span>\r\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token function\">put_fs_byte</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token char\">'\\0'</span><span class=\"token punctuation\">)</span> \r\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>值得注意的是，在编写代码过程中，我们可以通过 <code class=\"language-text\">printk()</code> 函数在屏幕上输出数据来进行调试，适当地向屏幕输出一些程序运行状态的信息，也是一种很高效、便捷的调试方法。</p>\n</blockquote>\n<h3>四、修改编译规则 Makefile</h3>\n<blockquote>\n<p>我们需要为新建的 <code class=\"language-text\">who.c</code> 文件添加编译规则来创建编译对象以及添加响应的依赖，后续即可使用 <code class=\"language-text\">make all</code> 一键编译。</p>\n</blockquote>\n<ul>\n<li>修改 <code class=\"language-text\">oslab_Lab2/linux-0.11/kernel/Makefile</code> 文件，修改如下：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">OBJS  = sched.o system_call.o traps.o asm.o fork.o \\\r\n    panic.o printk.o vsprintf.o sys.o exit.o \\\r\n    signal.o mktime.o who.o\r\n\r\n### Dependencies:\r\nwho.s who.o:  who.c ../include/linux/kernel.h ../include/unistd.h</code></pre></div>\n<h3>五、编写测试函数</h3>\n<blockquote>\n<p>编写两个测试函数，来测试我们编写的系统调用函数 sys_iam() 和 sys_whoami。</p>\n<ol>\n<li>iam.c：将字符串参数 name 的内容拷贝到内核中保存下来</li>\n<li>whoami.c：将内核中由 iam() 保存的名字拷贝到 name 指向的用户地址空间中并显示。</li>\n</ol>\n</blockquote>\n<ul>\n<li><strong>值得说明的是</strong>，我们编写后的两个测试函数需要在 linux-v0.11 环境下进行编译。由于 linux-v0.11 作为一个很小的操作系统，只有编译工具 vi ，使用起来非常不方便。因此，我们可以直接在 ubuntu 环境下进行编写，再通过挂载 <code class=\"language-text\">hdc</code> 磁盘来将这两个文件拷贝到 linux-v0.11 系统下，然后编译、运行。</li>\n</ul>\n<p><strong>1、在 <code class=\"language-text\">oslab_Lab2/linux-0.11/kernel</code> 文件夹下创建两个测试函数</strong></p>\n<ul>\n<li><strong>iam.c</strong>：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;errno.h></span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__LIBRARY__</span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\r\n\r\n<span class=\"token function\">_syscall1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> iam<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">iam</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>whoami.c</strong>：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__LIBRARY__</span></span>\r\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\r\n\r\n<span class=\"token function\">_syscall2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> whoami<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> agrv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">whoami</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>2、将两个测试函数移动到 linux-v0.11 系统下</strong></p>\n<blockquote>\n<p>通过挂载 hdc 磁盘，将编写的两个测试函数移动到 linux-v0.11 系统下，以便下一步进行编译。由于我们每在 ubuntu 系统下修改一次测试函数都要将其移动到 linux-v0.11 系统下进行编译，为了方便，我们可以编写一个 <strong>bash</strong> 脚本，存放如下命令。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> ~/my_space/OS_HIT/oslab_Lab2\r\n<span class=\"token function\">touch</span> cp.sh                                     // 创建脚本</code></pre></div>\n<p>脚本内容如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> ./mount-hdc                                // 挂载磁盘\r\n<span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> ./linux-0.11/kernel/iam.c ./hdc/iam.c          // 将 iam.c 移动到 hdc 磁盘\r\n<span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> ./linux-0.11/kernel/whoami.c ./hdc/whoami.c    // 将 whoami.c 移动到 hdc 磁盘\r\n<span class=\"token function\">sudo</span> <span class=\"token function\">umount</span> hdc                                 // 卸载\r\n./run                                           // 启动 linux-v0.11</code></pre></div>\n<p><strong>3、编译与运行</strong></p>\n<blockquote>\n<p>在编译之前，<strong>尤其注意</strong>，上述创建的 iam.c 和 whoami.c 两个文件中不能含有任何 <code class=\"language-text\">//</code> 之类的注释，否则在使用 linux-v0.11 系统进行编译时会报错。</p>\n</blockquote>\n<ul>\n<li>在 linux-v0.11 系统下，我们运行如下命令回到根目录，可以看到移动过来的 <code class=\"language-text\">iam.c</code> 和 <code class=\"language-text\">whoami.c</code> 文件。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span>/<span class=\"token punctuation\">..</span>\r\n<span class=\"token function\">ls</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 616px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/676dd1f01b0e56e8f07b4eaf2b4fe52f/40040/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 15.18987341772152%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAi0lEQVR42iWMOw7EIAwFISQLAoogSEHLrWiAkB8i4v7tPu26sMZjP5MQgvd+2zbnHOf88ytK6TzPQohpmv4AuSwLGCswLhljBEnMWGitCSEAay1ASol3AKWUMQanMMjArOuKFF6QMcZxHPu+p5RijDnn8zyv66q1wpdS0O/7hnmep7WG3nt/33eM8QXmaRvoLfDlOQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3\"\n        title=\"\"\n        src=\"/blog/static/676dd1f01b0e56e8f07b4eaf2b4fe52f/40040/3.png\"\n        srcset=\"/blog/static/676dd1f01b0e56e8f07b4eaf2b4fe52f/c26ae/3.png 158w,\n/blog/static/676dd1f01b0e56e8f07b4eaf2b4fe52f/6bdcf/3.png 315w,\n/blog/static/676dd1f01b0e56e8f07b4eaf2b4fe52f/40040/3.png 616w\"\n        sizes=\"(max-width: 616px) 100vw, 616px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>编译，运行如下指令，可以生成 <code class=\"language-text\">iam</code> 和 <code class=\"language-text\">whoami</code> 两个可执行文件。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcc -o iam iam.c -Wall           // 编译 iam.c 文件\r\ngcc -o whoami whoami.c -Wall     // 编译 whoami.c 文件\r\n// -Wall 是 GCC 的一个选项，用来开启所有警告</code></pre></div>\n<ul>\n<li>运行，分别运行两个文件，得到如下所示结果</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">./iam Joker      // 将 Joker 存入内核\r\n./whoami         // 从内核中取出 ./iam 存入的字符并显示</code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 221px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/110c8223cc191096eea146af356c7d84/cccdc/4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAElEQVR42pWPQatEYBSGPxcTJTKbKSnFRZkp0vwJ2UgIJUsLK39WFooV3QhTdrO5J7Ob7r11n8XpPV/nPe/5kCRJ5/P5fr/jOE7T9OVy0TTter0yDKPrum3blmUJgoAQwjAMvSGKIs/zMARmiqLAfLvdFEWBpaqqsiwLGwmCQD8CZo7jIOp0OoEZWgiUZfnzgCRJ9AemaUIsnAoG7ODj4CUgE/zELyD4MBxmGAaMov9SFEWe51VVZVlWlmUURUmSxHH8qmmaggiCwPf9MAyjA8dxXNf1PA/Vdd00zfP53Lat7/t1XaF+HSzLMgxD27bwMs9z13UgxnF8PB7TNO37/g2pplnUfNTX5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"在这里插入图片描述\"\n        title=\"\"\n        src=\"/blog/static/110c8223cc191096eea146af356c7d84/cccdc/4.png\"\n        srcset=\"/blog/static/110c8223cc191096eea146af356c7d84/c26ae/4.png 158w,\n/blog/static/110c8223cc191096eea146af356c7d84/cccdc/4.png 221w\"\n        sizes=\"(max-width: 221px) 100vw, 221px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>至此，Lab3 实验介绍完毕。</p>\n<hr>\n<p>也许有人觉得比较实验步骤比较多比较复杂，特此总结一下每个步骤：</p>\n<ol>\n<li>在 <code class=\"language-text\">hdc/usr/include/unistd.h</code> 中添加系统调用号 <code class=\"language-text\">__NR_iam</code> 和 <code class=\"language-text\">__NR_whoami</code></li>\n<li>在 <code class=\"language-text\">kernel/system_call.s</code> 修改系统调用总数  nr_system_calls = 74</li>\n<li>在 <code class=\"language-text\">include/linux/sys.h</code> 添加函数声明 <code class=\"language-text\">extern int sys_whoami();</code> 和 <code class=\"language-text\">extern int sys_iam();</code></li>\n<li>创建两个函数的实现：<code class=\"language-text\">/kernel/who.c</code></li>\n<li>在 <code class=\"language-text\">kernel/Makefile</code> 中添加编译规则</li>\n<li>在 <code class=\"language-text\">/kernel</code> 中创建测试函数 iam.c 和 whoami.c</li>\n<li>编写 bash 脚本，将测试函数移到 linux-v0.11 下</li>\n<li>在 Linux-v0.11 下编译 iam.c 和 whoami.c</li>\n</ol>","frontmatter":{"title":"【哈工大_操作系统实验】Lab3 系统调用","date":"September 11, 2024","description":"本文将介绍哈工大操作系统实验课Lab3 系统调用"}},"previous":{"fields":{"slug":"/011_HIT_OS_Lab2/"},"frontmatter":{"title":"【哈工大_操作系统实验】Lab2 操作系统的引导"}},"next":{"fields":{"slug":"/013_HIT_OS_Lab4/"},"frontmatter":{"title":"【哈工大_操作系统实验】Lab4 进程运行轨迹的跟踪与统计"}}},"pageContext":{"id":"cba3263f-08ed-5367-b800-3514ab6a2aa5","previousPostId":"24ad8171-270c-52c8-af14-cc2e10d6027e","nextPostId":"9480e2bf-816c-5fce-838a-d47165641f14"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}